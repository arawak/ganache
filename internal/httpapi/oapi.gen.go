// Package httpapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package httpapi

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for HealthStatus.
const (
	Ok HealthStatus = "ok"
)

// Defines values for MediaVariant.
const (
	MediaVariantContent  MediaVariant = "content"
	MediaVariantOriginal MediaVariant = "original"
	MediaVariantThumb    MediaVariant = "thumb"
)

// Defines values for Sort.
const (
	SortNewest    Sort = "newest"
	SortOldest    Sort = "oldest"
	SortRelevance Sort = "relevance"
)

// Defines values for SearchAssetsParamsSort.
const (
	SearchAssetsParamsSortNewest    SearchAssetsParamsSort = "newest"
	SearchAssetsParamsSortOldest    SearchAssetsParamsSort = "oldest"
	SearchAssetsParamsSortRelevance SearchAssetsParamsSort = "relevance"
)

// Defines values for GetMediaVariantParamsVariant.
const (
	GetMediaVariantParamsVariantContent  GetMediaVariantParamsVariant = "content"
	GetMediaVariantParamsVariantOriginal GetMediaVariantParamsVariant = "original"
	GetMediaVariantParamsVariantThumb    GetMediaVariantParamsVariant = "thumb"
)

// Asset defines model for Asset.
type Asset struct {
	Bytes            int64      `json:"bytes"`
	Caption          string     `json:"caption"`
	CreatedAt        time.Time  `json:"createdAt"`
	Credit           string     `json:"credit"`
	DeletedAt        *time.Time `json:"deletedAt"`
	Height           int        `json:"height"`
	Id               int64      `json:"id"`
	Mime             string     `json:"mime"`
	OriginalFilename *string    `json:"originalFilename,omitempty"`

	// Sha256 Hex-encoded SHA-256 of the original bytes (optional to expose).
	Sha256     *string          `json:"sha256,omitempty"`
	Source     string           `json:"source"`
	Tags       []string         `json:"tags"`
	Title      string           `json:"title"`
	UpdatedAt  time.Time        `json:"updatedAt"`
	UsageNotes string           `json:"usageNotes"`
	Variants   AssetVariantUrls `json:"variants"`
	Width      int              `json:"width"`
}

// AssetSearchResponse defines model for AssetSearchResponse.
type AssetSearchResponse struct {
	Items    []Asset `json:"items"`
	Page     int     `json:"page"`
	PageSize int     `json:"pageSize"`
	Total    int     `json:"total"`
}

// AssetUpdate defines model for AssetUpdate.
type AssetUpdate struct {
	Caption    *string   `json:"caption,omitempty"`
	Credit     *string   `json:"credit,omitempty"`
	Source     *string   `json:"source,omitempty"`
	Tags       *[]string `json:"tags,omitempty"`
	Title      *string   `json:"title,omitempty"`
	UsageNotes *string   `json:"usageNotes,omitempty"`
}

// AssetVariantUrls defines model for AssetVariantUrls.
type AssetVariantUrls struct {
	Content  string `json:"content"`
	Original string `json:"original"`
	Thumb    string `json:"thumb"`
}

// Error defines model for Error.
type Error struct {
	Code    string                  `json:"code"`
	Details *map[string]interface{} `json:"details,omitempty"`
	Message string                  `json:"message"`
}

// Health defines model for Health.
type Health struct {
	Status HealthStatus `json:"status"`
}

// HealthStatus defines model for Health.Status.
type HealthStatus string

// Tag defines model for Tag.
type Tag struct {
	Name string `json:"name"`
}

// TagListResponse defines model for TagListResponse.
type TagListResponse struct {
	Items []Tag `json:"items"`
}

// AssetId defines model for AssetId.
type AssetId = int64

// IncludeDeleted defines model for IncludeDeleted.
type IncludeDeleted = bool

// MediaVariant defines model for MediaVariant.
type MediaVariant string

// Page defines model for Page.
type Page = int

// PageSize defines model for PageSize.
type PageSize = int

// Query defines model for Query.
type Query = string

// Sort defines model for Sort.
type Sort string

// TagFilter defines model for TagFilter.
type TagFilter = []string

// SearchAssetsParams defines parameters for SearchAssets.
type SearchAssetsParams struct {
	// Q Full-text query (searched across title, caption, and tags).
	Q *Query `form:"q,omitempty" json:"q,omitempty"`

	// Tag Filter by tag name. Repeatable to require multiple tags.
	Tag      *TagFilter `form:"tag,omitempty" json:"tag,omitempty"`
	Page     *Page      `form:"page,omitempty" json:"page,omitempty"`
	PageSize *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Sort Sort order for search results.
	Sort *SearchAssetsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// IncludeDeleted Include soft-deleted assets in results (admin use).
	IncludeDeleted *IncludeDeleted `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`
}

// SearchAssetsParamsSort defines parameters for SearchAssets.
type SearchAssetsParamsSort string

// UploadAssetMultipartBody defines parameters for UploadAsset.
type UploadAssetMultipartBody struct {
	Caption    *string            `json:"caption,omitempty"`
	Credit     *string            `json:"credit,omitempty"`
	File       openapi_types.File `json:"file"`
	Source     *string            `json:"source,omitempty"`
	Tags       *[]string          `json:"tags,omitempty"`
	Title      *string            `json:"title,omitempty"`
	UsageNotes *string            `json:"usageNotes,omitempty"`
}

// ListTagsParams defines parameters for ListTags.
type ListTagsParams struct {
	// Prefix Prefix filter for tag autocomplete.
	Prefix   *string `form:"prefix,omitempty" json:"prefix,omitempty"`
	Page     *Page   `form:"page,omitempty" json:"page,omitempty"`
	PageSize *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// GetMediaVariantParamsVariant defines parameters for GetMediaVariant.
type GetMediaVariantParamsVariant string

// UploadAssetMultipartRequestBody defines body for UploadAsset for multipart/form-data ContentType.
type UploadAssetMultipartRequestBody UploadAssetMultipartBody

// UpdateAssetJSONRequestBody defines body for UpdateAsset for application/json ContentType.
type UpdateAssetJSONRequestBody = AssetUpdate

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Search and browse assets
	// (GET /api/assets)
	SearchAssets(w http.ResponseWriter, r *http.Request, params SearchAssetsParams)
	// Upload a new asset
	// (POST /api/assets)
	UploadAsset(w http.ResponseWriter, r *http.Request)
	// Soft delete an asset
	// (DELETE /api/assets/{id})
	DeleteAsset(w http.ResponseWriter, r *http.Request, id AssetId)
	// Get an asset by id
	// (GET /api/assets/{id})
	GetAsset(w http.ResponseWriter, r *http.Request, id AssetId)
	// Update asset metadata
	// (PATCH /api/assets/{id})
	UpdateAsset(w http.ResponseWriter, r *http.Request, id AssetId)
	// List tags (optionally by prefix)
	// (GET /api/tags)
	ListTags(w http.ResponseWriter, r *http.Request, params ListTagsParams)
	// Liveness check
	// (GET /healthz)
	GetHealthz(w http.ResponseWriter, r *http.Request)
	// Serve image bytes for an asset variant
	// (GET /media/{id}/{variant})
	GetMediaVariant(w http.ResponseWriter, r *http.Request, id AssetId, variant GetMediaVariantParamsVariant)
	// Readiness check
	// (GET /readyz)
	GetReadyz(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Search and browse assets
// (GET /api/assets)
func (_ Unimplemented) SearchAssets(w http.ResponseWriter, r *http.Request, params SearchAssetsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Upload a new asset
// (POST /api/assets)
func (_ Unimplemented) UploadAsset(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Soft delete an asset
// (DELETE /api/assets/{id})
func (_ Unimplemented) DeleteAsset(w http.ResponseWriter, r *http.Request, id AssetId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get an asset by id
// (GET /api/assets/{id})
func (_ Unimplemented) GetAsset(w http.ResponseWriter, r *http.Request, id AssetId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update asset metadata
// (PATCH /api/assets/{id})
func (_ Unimplemented) UpdateAsset(w http.ResponseWriter, r *http.Request, id AssetId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List tags (optionally by prefix)
// (GET /api/tags)
func (_ Unimplemented) ListTags(w http.ResponseWriter, r *http.Request, params ListTagsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Liveness check
// (GET /healthz)
func (_ Unimplemented) GetHealthz(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Serve image bytes for an asset variant
// (GET /media/{id}/{variant})
func (_ Unimplemented) GetMediaVariant(w http.ResponseWriter, r *http.Request, id AssetId, variant GetMediaVariantParamsVariant) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Readiness check
// (GET /readyz)
func (_ Unimplemented) GetReadyz(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// SearchAssets operation middleware
func (siw *ServerInterfaceWrapper) SearchAssets(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchAssetsParams

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", r.URL.Query(), &params.Tag)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tag", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "includeDeleted" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeDeleted", r.URL.Query(), &params.IncludeDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDeleted", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchAssets(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UploadAsset operation middleware
func (siw *ServerInterfaceWrapper) UploadAsset(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadAsset(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteAsset operation middleware
func (siw *ServerInterfaceWrapper) DeleteAsset(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id AssetId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAsset(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAsset operation middleware
func (siw *ServerInterfaceWrapper) GetAsset(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id AssetId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAsset(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateAsset operation middleware
func (siw *ServerInterfaceWrapper) UpdateAsset(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id AssetId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateAsset(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListTags operation middleware
func (siw *ServerInterfaceWrapper) ListTags(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTagsParams

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "prefix", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListTags(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHealthz operation middleware
func (siw *ServerInterfaceWrapper) GetHealthz(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHealthz(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMediaVariant operation middleware
func (siw *ServerInterfaceWrapper) GetMediaVariant(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id AssetId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "variant" -------------
	var variant GetMediaVariantParamsVariant

	err = runtime.BindStyledParameterWithOptions("simple", "variant", chi.URLParam(r, "variant"), &variant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "variant", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMediaVariant(w, r, id, variant)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetReadyz operation middleware
func (siw *ServerInterfaceWrapper) GetReadyz(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetReadyz(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/assets", wrapper.SearchAssets)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/assets", wrapper.UploadAsset)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/assets/{id}", wrapper.DeleteAsset)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/assets/{id}", wrapper.GetAsset)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/api/assets/{id}", wrapper.UpdateAsset)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/tags", wrapper.ListTags)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/healthz", wrapper.GetHealthz)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/media/{id}/{variant}", wrapper.GetMediaVariant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/readyz", wrapper.GetReadyz)
	})

	return r
}
